1. Введение в шаблоны проектирования
2. Основные понятия ООП.
3. Порождающие шаблоны. (AbstractFactory, Builder, FactoryMethod, Prototype, Singleton)
4. Структурные шаблоны. (Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy)
5. Шаблоны поведения. (ChainOfResponsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer
                       State, Strategy, Template, Visitor)
6. Заключение

1. Шаблон проектирования - это именованное эффективное решение характерной задачи проектирования программного
                           обеспечения.


2. ООП - парадигма программирования, в которой ключевым блоком явл объект, к-й соотносится с объектом в конкретной задаче.

        Главные аспекты:
           - любая система состоит из объектов;
           - каждый объект имеет состояние и поведение;
           - объекты взаимодействуют между собой определенным способом;

        Принципы ООП:
           - Инкапсуляция;
           - Наследование;
           - Полиморфизм

        Инкапсуляция:
           - Механизм, благодаря которому любой класс или часть системы рассматривается как отдельный модуль
           и пользователь этого модуля может взаимодействовать с ним только определенными способами и не видит
           реализации этого модуля;
           - Сводит к минимуму количество связей между частями системы, тем самым,
           упрощая изменение модулей (рефакторинг).

        Наследование:
           - Механизм создания одного класса с помощью другого с использованием всех свойств и методов
           супер-класса добавляя новые свойства и методы при необходимости;
           - отображает иерархичность окружающего мира.

        Полиморфизм:
           - Механизм, благодаря которому подклассы могут изменять реализацию методов супер-класса, сохраняя
           его сигнатуру, благодаря чему интерфейс супер-класса остается неизменным;
           - позволяет работать с объектами подклассов как с объектами супер-класса, даже с учетом того,
           что реализация определенных методов у подклассов может отличаться от реализации методов супер-класса.

        UML

   Unified Modeling Language
   Универсальный язык моделирования

3.1. Шаблон: Абстрактная фабрика (Abstract factory)

            Цель:
   Создание интерфейса, для создания множества взаимосвязанных или взаимозависимых объектов, без жесткой
   привязке к конкретным классам.

            Для чего используется:
   Для создания множеств взаимосвязанных объектов.

            Пример использования:
   - система не должна зависеть от метода создания, компоновки и представления входящих в нее объектов;
   - входящие взаимосвязанные объекты должны использоваться вместе;
   - система должна конфигурироваться одним из множеств объектов, из которых она состоит;
   - нам необходимо предоставить множество объектов, раскрывая только их интерфейсы, но не реализацию.

3.2. Шаблон: Строитель (Builder)

            Цель:
     Отделить конструирование сложного объекта от его представления таким образом, чтобы в результате
     одного и того же конструирования мы могли получить разные представления.

            Для чего используется:
     Для создания различных объектов из одного набора данных.

            Пример использования:
     - порядок создания сложного объекта не должен зависеть от того, из каких частей состоит объект и
       того, как эти объекты взаимосвязаны;
     - процесс конструирования объекта должен предоставлять различные представления объекта, который мы
       конструируем.

3.3. Шаблон: Фабрика (Factory Method)

            Цель:
     Создание интерфейса, который создает объект. При этом, выбор того, экземпляр какого класса создавать
     остается за классами, которые имплементируют данный интерфейс.

            Для чего используется:
     Для делегирования создания экземпляров, другому классу.

            Пример использования:
     - заранее неизвестно, экземпляры, какого класса нужно будет создавать;
     - класс спроектирован таким образом, что создаваемые им объекты имеют свойства определенного класса.

3.4. Шаблон: Прототип (Prototype)

            Цель:
     Определить вид создаваемых объектов с помощью экземпляра - прототипа и создавать новые объекты,
     копируя этот прототип.

            Для чего используется:
     Для создания копий заданного объекта.

            Пример использования:
     - классы, экземпляры которых необходимо создать, определяются во время выполнения программы;
     - для избежания построения иерархии классов, фабрик или параллельных иерархий классов;
     - экземпляры класса могут находиться в одной из немногих возможных состояний.

3.5. Шаблон: Одиночка (Singleton)

            Цель:
     Гарантировать, что у класса будет только один единственный экземпляр и к нему будет предоставлена
     глобальная точка доступа.

            Для чего используется:
     Для создания единственного экземпляра определенного класса.

            Пример использования:
     - необходим только один экземпляр конкретного класса, который доступен для всех клиентов;
     - единственный экземпляр должен наследоваться путем порождения подклассов, при этом, клиенты
       имеют возможность работать с классом-наследником без модификации своего кода.

4.1. Шаблон: Адаптер (Adapter)

            Цель:
     Преобразование интерфейса одного класса в интерфейс того класса, который необходим клиенту.

            Для чего используется:
     Для обеспечения совместной работы классов, интерфейсы которых не совместимы.

            Пример использования:
     - интерфейс класса, который мы хотим использовать и не соответствует нашим потребностям;
     - необходим класс, который должен взаимодействовать с классами, которые ему неизвестны
       или не связаны с нми;
     - необходимо использовать несколько существующих подклассов, но нецелесообразно использовать
       методы этих классов создавая их новые подклассы.

4.2. Шаблон: Мост (Bridge)

            Цель:
     Отделить абстракцию от её реализации таким образом, чтобы мы могли изменять независимо друг от друга
     и то и другое.

            Для чего используется:
     Для получения преимуществ наследования без потери гибкости.

            Пример использования:
     - предотвращения жёсткой привязки абстракции к реализации (например, реализацию необходимо выбрать
       во время выполнения программы);
     - в будущем мы хотим расширять с помощью подклассов и реализацию и абстракцию;
     - если изменения в реализации не должны отражаться на клиентах абстракции;
     - для разделения одной реализации между несколькими объектами и не показывать это клиенту.

4.3. Шаблон: Компоновщик (Composite)

            Цель:

     Скомпоновать объекты в структуры по типу "дерева", позволяя клиентам единообразно трактовать
     отдельные и составные объекты.

            Для чего используется:
     Для группировки мелких компонентов в более крупные, которые, в совю очередь, могут стать основой для
     еще более крупных структур.

            Пример использования:
     - для представления иерархии "часть-целое";
     - мы хотим, чтобы клиенты одним способом трактовали как отдельные, так и составные объекты.

4.4. Шаблон: Декоратор (Decorator)

            Цель:
     Динамические добавление новых обязанностей объекту.

            Для чего используется:
     Используется в качестве альтернативы порождению подклассов для расширения функциональности.

            Пример использования:
     - динамическое и понятное клиентам добавления обязанностей объектам;
     - реализация обязанностей, которые могут быть сняты с объекта;
     - расширение класса путем порождения подклассов невозможно по каким-либо причинам.

4.5. Шаблон: Фасад (Facade)

            Цель:
     Предоставить унифицированный интерфейс вместо нескольких интерфейсов подсистем.

            Для чего используется:
     Используется для определения интерфейса высокого уровня, который упрощает использование подсистемы.

            Пример использования:
     - изолирование клиентов от компонентов подсистемы, упрощая работу с ней;
     - необходимость ослабления связанности подсистемы с клиентами;

4.6. Шаблон: Приспособленец (Flyweight)

            Цель:
     Поддержка множества мелких объектов.

            Для чего используется:
     Использует разделение для того, чтобы поддерживать много мелких объектов.

            Пример использования:
     - когда используется большое число объектов;
        - большую часть состояния объектов можно вынести наружу;
        - приложение не зависит от идентичности объекта.

4.7. Шаблон: Прокси (Proxy)

            Цель:
     Для замещения другого объекта и контроля доступа к нему.

            Для чего используется:
     Для обеспечения контроля доступа к определенному объекту.

            Пример использования:
     - когда есть необходимость ссылаться на объект способом отличным от обычного указателя;
         * удаленное замещение -     локальный представитель вместо объекта в другом
                                     адресном пространстве.

         * виртуальное замещение -   создание "тяжёлых объектов" при необходимости.

         * защищенное замещение -    контроль доступа к указанному объекту

         * "умная" ссылка -          замена обычного указателя
                                     (подсчёт числа ссылок, установка блокировки и т.д.)

5.1. Шаблон: Цепочка ответственности (Chain Of Responsibility)

             Цель:
         Связывание объектов-получателей в цепочку и передача запроса по ней.

             Для чего используется:
         Помогает избежать привязки отправителя запроса к его получателю, что даёт возможность обработать
         данный запрос нескольким объектам.

             Пример использования:
         - ослабление привязанности (объект не должен знать, кто именно обработает его запрос);
         - дополнительная гибкость при распределении обязанностей между объектами;

5.2. Шаблон: Команда (Command)

            Цель:
     Инкапсуляция запроса в объект

            Для чего используется:
     Чтобы задать параметры клиентов для обработки определенных запросов, создание очереди из этих запросов
     или их контроля и поддержки отмены операций.

            Пример использования:
     - параметризация объектов выполняемым действием;
     - определять запрос, ставить его в очередь или выполнять его в разное время

5.3. Шаблон: Интерпретатор (Interpreter)

            Цель:
     Определение представления грамматики объекта

            Для чего используется:
     Используется для определения представления грамматики заданного языка и интерпретации его предложений

            Пример использования:
     - упрощение иерархии классов с помощью интерпретирования

5.4. Шаблон: Итератор (Iterator)

            Цель:
     Получение последовательного доступа ко всем элементам составного объекта.

            Для чего используется:
     Для получения последовательного доступа ко всем элементам составного объекта, скрывая его
     внутреннее представление.

            Пример использования:
     - различные виды обхода составного объекта;
     - упрощенный доступ к составному объекту.

5.5. Шаблон: Посредник (Mediator)

            Цель:
     Инкапсуляция способа взаимодействия множества объектов

            Для чего используется:
     Для определения объекта, который инкапсулирует способ взаимодействия множества объектов и обеспечения
     слабой связи между этими объектами.

            Пример использования:
     - связи между объектами сложны и четко определены;
     - нельзя повторно использовать объект, так как он обменивается информацией с другими объектам;
     - поведение, распределенное между несколькими классами должно легко настраиваться без создания
       подклассов.

5.6. Шаблон: Хранитель (Memento)

            Цель:
     Сохранить внутренне состояние объекта за его пределы.

            Для чего используется:
     Фиксирование внутреннего состояния объекта за его пределами не нарушая инкапсуляцию
     и восстановления объекта в случае необходимости.

            Пример использования:
     - необходимо сохранить текущее состояние объекта или его части и восстановление в будущем, но
       прямое получение состояние раскрывает детали реализации и нарушает инкапсуляцию.

5.7. Шаблон: Наблюдатель (Observer)

            Цель:
     Определение зависимости "один ко многим" между объектами.

            Для чего используется:
     Определение зависимости "один ко многим" между объектами таким образом, что при изменении
     состояния одного объекта все зависящие от него объекты были уведомлены об этом и обновились.

            Пример использования:
     - когда у модели имеются два аспекта, один из которых зависит от другого. Инкапсулирование
       этих аспектов в разные классы позволяют использовать их независимо друг от друга;
     - когда один объект должен оповещать другие и не делать предположений об этих объектах;
     - ослабление связи между объектами.

5.8. Шаблон: Состояние (State)

            Цель:
     Управление поведением объекта в зависимости от состояния.

            Для чего используется:
     Позволяет нам управлять поведение объекта в зависимости от внутреннего состояние объекта.

            Пример использования:
     - поведение объекта зависит от его соятояние и изменяется во время выполнения;
     - когда встречается большое количество условных операторов, когда выбор ветви
       зависит от состояния объекта.

5.9. Шаблон: Стратегия (Strategy)

            Цель:
     Взаимодействовать семейства классов

            Для чего используется:
     Определение семейств классов, инкапсулирование каждого из них и организация
     их взаимозаменяемости.

            Пример использования:
     - есть несколько родственных классов, которые отличаются поведением;
     - необходимо иметь несколько вариантов поведения;
     - в классе есть данные, о которых не должен знать клиент;
     - с помощью условных операторов в классе определено большое количество возможных поведений.

5.10. Шаблон: Шаблонный метод (Template)

            Цель:
      Определение основы класса и создание возможности подклассам переопределить его части.

            Для чего используется:
      Определяет основу класса и позволяет подклассам переопределять некоторые его части
      не изменяя его структуру в целом.

            Пример использования:
      - однократное использование различных частей класса, оставляя реализацию изменяющегося
        поведения на усмотрения подклассов;
      - вычленение и локализация общего для всех подклассов поведения в родительском;
      - управление расширениями подклассов.

5.11. Шаблон: Посетитель (Visitor)

            Цель:
      Описание действий, которые выполняются с каждым объектом в некоторой структуре

            Для чего используется:
      Описание операций, которые выполняются с каждым объектом из некоторой структуры.
      Позволяет определить новую операцию без изменения классов этих объектов.

            Пример использования:
      - в структуре присутствуют объекты многих классов с различными интерфейсами и нам
        необходимо выполнить над ними операции, которые зависят от конкретных классов;
      - необходимо выполнять не связанные между собой операции над объектами, которые
        входят в состав структуры и мы не хотим добавлять эти операции в классы;
      - классы, которые устанавливают структуру объектов редко изменяются, но часто
        добавляются новые операции над этой структурой.

6.1.